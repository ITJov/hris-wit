// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: dashboard.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const getInventarisStats = `-- name: GetInventarisStats :one
SELECT
    COUNT(i.inventaris_id) AS total_inventaris,
    COUNT(CASE
              WHEN i.status = 'Tidak Aktif' THEN 1
              ELSE NULL
        END) AS rusak_maintenance,
    COUNT(CASE
              WHEN i.status = 'Aktif' AND p.status_peminjaman = 'Sedang Dipinjam' THEN 1
              ELSE NULL
        END) AS sedang_dipinjam,
    COUNT(CASE
              WHEN i.status = 'Aktif' AND p.status_peminjaman IS NULL THEN 1
              ELSE NULL
        END) AS tersedia
FROM inventaris i
         LEFT JOIN peminjaman p ON i.inventaris_id = p.inventaris_id AND p.deleted_at IS NULL
WHERE i.deleted_at IS NULL
`

type GetInventarisStatsRow struct {
	TotalInventaris  int64 `json:"total_inventaris"`
	RusakMaintenance int64 `json:"rusak_maintenance"`
	SedangDipinjam   int64 `json:"sedang_dipinjam"`
	Tersedia         int64 `json:"tersedia"`
}

func (q *Queries) GetInventarisStats(ctx context.Context) (GetInventarisStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getInventarisStats)
	var i GetInventarisStatsRow
	err := row.Scan(
		&i.TotalInventaris,
		&i.RusakMaintenance,
		&i.SedangDipinjam,
		&i.Tersedia,
	)
	return i, err
}

const listNewVendors = `-- name: ListNewVendors :many
SELECT
    v.vendor_id,
    v.nama_vendor,
    kv.isi_kontak AS kontak_vendor,
    kv.jenis_kontak,
    v.created_at
FROM vendor v
         LEFT JOIN kontak_vendor kv ON v.vendor_id = kv.vendor_id AND kv.is_primary = TRUE AND kv.deleted_at IS NULL
WHERE v.deleted_at IS NULL
ORDER BY v.created_at DESC
    LIMIT 2
`

type ListNewVendorsRow struct {
	VendorID     string         `json:"vendor_id"`
	NamaVendor   string         `json:"nama_vendor"`
	KontakVendor sql.NullString `json:"kontak_vendor"`
	JenisKontak  interface{}    `json:"jenis_kontak"`
	CreatedAt    time.Time      `json:"created_at"`
}

func (q *Queries) ListNewVendors(ctx context.Context) ([]ListNewVendorsRow, error) {
	rows, err := q.db.QueryContext(ctx, listNewVendors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNewVendorsRow
	for rows.Next() {
		var i ListNewVendorsRow
		if err := rows.Scan(
			&i.VendorID,
			&i.NamaVendor,
			&i.KontakVendor,
			&i.JenisKontak,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotReturnedInventaris = `-- name: ListNotReturnedInventaris :many
SELECT
    p.peminjaman_id,
    i.nama_inventaris,
    p.tgl_pinjam,
    p.tgl_kembali AS tanggal_kembali_rencana,
    ub.name AS nama_peminjam
FROM peminjaman p
         JOIN inventaris i ON p.inventaris_id = i.inventaris_id
         JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.deleted_at IS NULL
  AND p.status_peminjaman = 'Sedang Dipinjam' -- Hanya yang statusnya masih 'Sedang Dipinjam'
  AND p.tgl_kembali < (now() at time zone 'UTC')::DATE -- Dan tanggal kembali rencana sudah lewat
ORDER BY p.tgl_kembali ASC
`

type ListNotReturnedInventarisRow struct {
	PeminjamanID          string         `json:"peminjaman_id"`
	NamaInventaris        string         `json:"nama_inventaris"`
	TglPinjam             time.Time      `json:"tgl_pinjam"`
	TanggalKembaliRencana time.Time      `json:"tanggal_kembali_rencana"`
	NamaPeminjam          sql.NullString `json:"nama_peminjam"`
}

func (q *Queries) ListNotReturnedInventaris(ctx context.Context) ([]ListNotReturnedInventarisRow, error) {
	rows, err := q.db.QueryContext(ctx, listNotReturnedInventaris)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotReturnedInventarisRow
	for rows.Next() {
		var i ListNotReturnedInventarisRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.NamaInventaris,
			&i.TglPinjam,
			&i.TanggalKembaliRencana,
			&i.NamaPeminjam,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentActivities = `-- name: ListRecentActivities :many
SELECT
    p.peminjaman_id,
    p.tgl_pinjam,
    p.tgl_kembali,
    p.status_peminjaman, -- Ini adalah nilai ENUM aslinya
    i.nama_inventaris,
    ub.name AS nama_peminjam_user,
    CASE
        -- Jika 'Tidak Dipinjam' berarti sudah selesai/dikembalikan:
        WHEN p.status_peminjaman = 'Tidak Dipinjam' THEN 'Dikembalikan'
        -- Jika 'Sedang Dipinjam' berarti masih dipinjam:
        WHEN p.status_peminjaman = 'Sedang Dipinjam' THEN 'Dipinjam'
        -- Tambahkan kasus untuk 'Menunggu Persetujuan' jika perlu ditampilkan di status_display
        WHEN p.status_peminjaman = 'Menunggu Persetujuan' THEN 'Menunggu Persetujuan' -- Menggunakan string yang cocok
        ELSE 'Lainnya' -- Fallback jika ada status lain yang tidak ditangani
        END AS status_display
FROM peminjaman p
         LEFT JOIN inventaris i ON p.inventaris_id = i.inventaris_id
         LEFT JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC
    LIMIT 5
`

type ListRecentActivitiesRow struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	NamaInventaris   sql.NullString       `json:"nama_inventaris"`
	NamaPeminjamUser sql.NullString       `json:"nama_peminjam_user"`
	StatusDisplay    string               `json:"status_display"`
}

func (q *Queries) ListRecentActivities(ctx context.Context) ([]ListRecentActivitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentActivities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentActivitiesRow
	for rows.Next() {
		var i ListRecentActivitiesRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.TglPinjam,
			&i.TglKembali,
			&i.StatusPeminjaman,
			&i.NamaInventaris,
			&i.NamaPeminjamUser,
			&i.StatusDisplay,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentPeminjam = `-- name: ListRecentPeminjam :many
SELECT
    ub.guid AS user_id,
    ub.name AS nama_peminjam,
    MAX(p.tgl_pinjam) AS tanggal_terakhir_pinjam
FROM peminjaman p
         JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.deleted_at IS NULL
GROUP BY ub.guid, ub.name
ORDER BY tanggal_terakhir_pinjam DESC
    LIMIT 2
`

type ListRecentPeminjamRow struct {
	UserID                string         `json:"user_id"`
	NamaPeminjam          sql.NullString `json:"nama_peminjam"`
	TanggalTerakhirPinjam interface{}    `json:"tanggal_terakhir_pinjam"`
}

func (q *Queries) ListRecentPeminjam(ctx context.Context) ([]ListRecentPeminjamRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecentPeminjam)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecentPeminjamRow
	for rows.Next() {
		var i ListRecentPeminjamRow
		if err := rows.Scan(&i.UserID, &i.NamaPeminjam, &i.TanggalTerakhirPinjam); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
