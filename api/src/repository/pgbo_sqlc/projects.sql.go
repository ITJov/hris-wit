// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: projects.sql

package sqlc

import (
	"context"
	"database/sql"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    client_id, project_name, project_desc, project_status,
    project_priority, project_color, start_date, due_date,
    created_at, created_by
) VALUES (
     $1, $2, $3, $4::project_status_enum,
    $5, $6, $7, $8,
    (now() at time zone 'UTC')::TIMESTAMP, $9
) RETURNING project_id
`

type CreateProjectParams struct {
	ClientID        string         `json:"client_id"`
	ProjectName     sql.NullString `json:"project_name"`
	ProjectDesc     sql.NullString `json:"project_desc"`
	ProjectStatus   interface{}    `json:"project_status"`
	ProjectPriority sql.NullString `json:"project_priority"`
	ProjectColor    sql.NullString `json:"project_color"`
	StartDate       sql.NullTime   `json:"start_date"`
	DueDate         sql.NullTime   `json:"due_date"`
	CreatedBy       string         `json:"created_by"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (string, error) {
	row := q.db.QueryRowContext(ctx, createProject,
		arg.ClientID,
		arg.ProjectName,
		arg.ProjectDesc,
		arg.ProjectStatus,
		arg.ProjectPriority,
		arg.ProjectColor,
		arg.StartDate,
		arg.DueDate,
		arg.CreatedBy,
	)
	var project_id string
	err := row.Scan(&project_id)
	return project_id, err
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, project_id, client_id, project_name, project_desc, project_status, project_priority, project_color, start_date, due_date, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by FROM projects
WHERE project_id = $1
  AND deleted_at IS NULL
`

func (q *Queries) GetProjectByID(ctx context.Context, projectID string) (Project, error) {
	row := q.db.QueryRowContext(ctx, getProjectByID, projectID)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ClientID,
		&i.ProjectName,
		&i.ProjectDesc,
		&i.ProjectStatus,
		&i.ProjectPriority,
		&i.ProjectColor,
		&i.StartDate,
		&i.DueDate,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listProjects = `-- name: ListProjects :many
SELECT id, project_id, client_id, project_name, project_desc, project_status, project_priority, project_color, start_date, due_date, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by FROM projects
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.ClientID,
			&i.ProjectName,
			&i.ProjectDesc,
			&i.ProjectStatus,
			&i.ProjectPriority,
			&i.ProjectColor,
			&i.StartDate,
			&i.DueDate,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreProject = `-- name: RestoreProject :exec
UPDATE projects
SET
    deleted_at = NULL,
    deleted_by = NULL
WHERE project_id = $1
`

func (q *Queries) RestoreProject(ctx context.Context, projectID string) error {
	_, err := q.db.ExecContext(ctx, restoreProject, projectID)
	return err
}

const softDeleteProject = `-- name: SoftDeleteProject :exec
UPDATE projects
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE project_id = $2
`

type SoftDeleteProjectParams struct {
	DeletedBy sql.NullString `json:"deleted_by"`
	ProjectID string         `json:"project_id"`
}

func (q *Queries) SoftDeleteProject(ctx context.Context, arg SoftDeleteProjectParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteProject, arg.DeletedBy, arg.ProjectID)
	return err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET
    project_name = $1,
    project_desc = $2,
    project_status = $3::project_status_enum,
    project_priority = $4,
    project_color = $5,
    start_date = $6,
    due_date = $7,
    client_id = $8,
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $9
WHERE project_id = $10
  AND deleted_at IS NULL
RETURNING id, project_id, client_id, project_name, project_desc, project_status, project_priority, project_color, start_date, due_date, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type UpdateProjectParams struct {
	ProjectName     sql.NullString `json:"project_name"`
	ProjectDesc     sql.NullString `json:"project_desc"`
	ProjectStatus   interface{}    `json:"project_status"`
	ProjectPriority sql.NullString `json:"project_priority"`
	ProjectColor    sql.NullString `json:"project_color"`
	StartDate       sql.NullTime   `json:"start_date"`
	DueDate         sql.NullTime   `json:"due_date"`
	ClientID        string         `json:"client_id"`
	UpdatedBy       sql.NullString `json:"updated_by"`
	ProjectID       string         `json:"project_id"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (Project, error) {
	row := q.db.QueryRowContext(ctx, updateProject,
		arg.ProjectName,
		arg.ProjectDesc,
		arg.ProjectStatus,
		arg.ProjectPriority,
		arg.ProjectColor,
		arg.StartDate,
		arg.DueDate,
		arg.ClientID,
		arg.UpdatedBy,
		arg.ProjectID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.ClientID,
		&i.ProjectName,
		&i.ProjectDesc,
		&i.ProjectStatus,
		&i.ProjectPriority,
		&i.ProjectColor,
		&i.StartDate,
		&i.DueDate,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
