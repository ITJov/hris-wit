// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: peminjaman.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const createPeminjaman = `-- name: CreatePeminjaman :one
INSERT INTO peminjaman (
    peminjaman_id,
    inventaris_id,
    user_id,
    tgl_pinjam,
    tgl_kembali,
    status_peminjaman,
    notes,
    created_at,
    created_by
) VALUES (
             $1,
             $2,
             $3,
             $4,
             $5,
             $6::status_peminjaman_enum,
             $7,
             (now() at time zone 'UTC')::TIMESTAMP,
             $8
         )
    RETURNING id, user_id, peminjaman_id, inventaris_id, tgl_pinjam, tgl_kembali, status_peminjaman, notes, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type CreatePeminjamanParams struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	InventarisID     string               `json:"inventaris_id"`
	UserID           string               `json:"user_id"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	Notes            sql.NullString       `json:"notes"`
	CreatedBy        string               `json:"created_by"`
}

func (q *Queries) CreatePeminjaman(ctx context.Context, arg CreatePeminjamanParams) (Peminjaman, error) {
	row := q.db.QueryRowContext(ctx, createPeminjaman,
		arg.PeminjamanID,
		arg.InventarisID,
		arg.UserID,
		arg.TglPinjam,
		arg.TglKembali,
		arg.StatusPeminjaman,
		arg.Notes,
		arg.CreatedBy,
	)
	var i Peminjaman
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PeminjamanID,
		&i.InventarisID,
		&i.TglPinjam,
		&i.TglKembali,
		&i.StatusPeminjaman,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getPeminjamanByID = `-- name: GetPeminjamanByID :one
SELECT
    p.peminjaman_id,
    p.tgl_pinjam,
    p.tgl_kembali,
    p.status_peminjaman,
    p.notes,
    i.nama_inventaris,
    ub.name AS nama_peminjam_user
FROM peminjaman p
         LEFT JOIN inventaris i ON p.inventaris_id = i.inventaris_id
         LEFT JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.peminjaman_id = $1 AND p.deleted_at IS NULL
`

type GetPeminjamanByIDRow struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	Notes            sql.NullString       `json:"notes"`
	NamaInventaris   sql.NullString       `json:"nama_inventaris"`
	NamaPeminjamUser sql.NullString       `json:"nama_peminjam_user"`
}

func (q *Queries) GetPeminjamanByID(ctx context.Context, peminjamanID string) (GetPeminjamanByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getPeminjamanByID, peminjamanID)
	var i GetPeminjamanByIDRow
	err := row.Scan(
		&i.PeminjamanID,
		&i.TglPinjam,
		&i.TglKembali,
		&i.StatusPeminjaman,
		&i.Notes,
		&i.NamaInventaris,
		&i.NamaPeminjamUser,
	)
	return i, err
}

const listAvailableInventaris = `-- name: ListAvailableInventaris :many
SELECT
    i.inventaris_id,
    i.nama_inventaris,
    i.status, -- Status inventaris (Aktif/Tidak Aktif)
    i.keterangan
FROM inventaris i
         LEFT JOIN peminjaman p ON i.inventaris_id = p.inventaris_id AND p.deleted_at IS NULL AND p.status_peminjaman = 'Sedang Dipinjam'
WHERE i.deleted_at IS NULL
  AND i.status = 'Aktif'
  AND p.peminjaman_id IS NULL
ORDER BY i.nama_inventaris ASC
`

type ListAvailableInventarisRow struct {
	InventarisID   string         `json:"inventaris_id"`
	NamaInventaris string         `json:"nama_inventaris"`
	Status         interface{}    `json:"status"`
	Keterangan     sql.NullString `json:"keterangan"`
}

func (q *Queries) ListAvailableInventaris(ctx context.Context) ([]ListAvailableInventarisRow, error) {
	rows, err := q.db.QueryContext(ctx, listAvailableInventaris)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAvailableInventarisRow
	for rows.Next() {
		var i ListAvailableInventarisRow
		if err := rows.Scan(
			&i.InventarisID,
			&i.NamaInventaris,
			&i.Status,
			&i.Keterangan,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listOverduePeminjamanByUserID = `-- name: ListOverduePeminjamanByUserID :many
SELECT
    p.peminjaman_id,
    i.nama_inventaris,
    p.tgl_kembali, -- Ini adalah tanggal kembali rencana
    p.tgl_pinjam,
    p.status_peminjaman
FROM peminjaman p
         JOIN inventaris i ON p.inventaris_id = i.inventaris_id
WHERE p.user_id = $1
  AND p.status_peminjaman = 'Sedang Dipinjam'
  AND p.tgl_kembali < (now() at time zone 'UTC')::DATE -- Tanggal kembali sudah lewat
  AND p.deleted_at IS NULL
ORDER BY p.tgl_kembali ASC
`

type ListOverduePeminjamanByUserIDRow struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	NamaInventaris   string               `json:"nama_inventaris"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
}

func (q *Queries) ListOverduePeminjamanByUserID(ctx context.Context, userID string) ([]ListOverduePeminjamanByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listOverduePeminjamanByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListOverduePeminjamanByUserIDRow
	for rows.Next() {
		var i ListOverduePeminjamanByUserIDRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.NamaInventaris,
			&i.TglKembali,
			&i.TglPinjam,
			&i.StatusPeminjaman,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeminjaman = `-- name: ListPeminjaman :many
SELECT
    p.peminjaman_id,
    p.tgl_pinjam,
    p.tgl_kembali,
    p.status_peminjaman,
    p.notes,
    i.nama_inventaris,
    ub.name AS nama_peminjam_user
FROM peminjaman p
         LEFT JOIN inventaris i ON p.inventaris_id = i.inventaris_id
         LEFT JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.deleted_at IS NULL
ORDER BY p.created_at DESC
`

type ListPeminjamanRow struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	Notes            sql.NullString       `json:"notes"`
	NamaInventaris   sql.NullString       `json:"nama_inventaris"`
	NamaPeminjamUser sql.NullString       `json:"nama_peminjam_user"`
}

func (q *Queries) ListPeminjaman(ctx context.Context) ([]ListPeminjamanRow, error) {
	rows, err := q.db.QueryContext(ctx, listPeminjaman)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPeminjamanRow
	for rows.Next() {
		var i ListPeminjamanRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.TglPinjam,
			&i.TglKembali,
			&i.StatusPeminjaman,
			&i.Notes,
			&i.NamaInventaris,
			&i.NamaPeminjamUser,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPeminjamanByUserID = `-- name: ListPeminjamanByUserID :many
SELECT
    p.peminjaman_id,
    p.tgl_pinjam,
    p.tgl_kembali,
    p.status_peminjaman,
    p.notes,
    i.nama_inventaris -- Ambil nama inventaris
FROM peminjaman p
         JOIN inventaris i ON p.inventaris_id = i.inventaris_id
WHERE p.user_id = $1 AND p.deleted_at IS NULL
ORDER BY p.created_at DESC
`

type ListPeminjamanByUserIDRow struct {
	PeminjamanID     string               `json:"peminjaman_id"`
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	Notes            sql.NullString       `json:"notes"`
	NamaInventaris   string               `json:"nama_inventaris"`
}

func (q *Queries) ListPeminjamanByUserID(ctx context.Context, userID string) ([]ListPeminjamanByUserIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listPeminjamanByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPeminjamanByUserIDRow
	for rows.Next() {
		var i ListPeminjamanByUserIDRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.TglPinjam,
			&i.TglKembali,
			&i.StatusPeminjaman,
			&i.Notes,
			&i.NamaInventaris,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingPeminjaman = `-- name: ListPendingPeminjaman :many
SELECT
    p.peminjaman_id,
    p.tgl_pinjam,
    p.tgl_kembali,
    p.notes,
    i.nama_inventaris,
    ub.name AS nama_peminjam_user, -- Nama user yang mengajukan
    ub.guid AS user_id_peminjam -- ID user yang mengajukan
FROM peminjaman p
         JOIN inventaris i ON p.inventaris_id = i.inventaris_id
         JOIN user_backoffice ub ON p.user_id = ub.guid
WHERE p.status_peminjaman = 'Menunggu Persetujuan' AND p.deleted_at IS NULL
ORDER BY p.created_at ASC
`

type ListPendingPeminjamanRow struct {
	PeminjamanID     string         `json:"peminjaman_id"`
	TglPinjam        time.Time      `json:"tgl_pinjam"`
	TglKembali       time.Time      `json:"tgl_kembali"`
	Notes            sql.NullString `json:"notes"`
	NamaInventaris   string         `json:"nama_inventaris"`
	NamaPeminjamUser sql.NullString `json:"nama_peminjam_user"`
	UserIDPeminjam   string         `json:"user_id_peminjam"`
}

func (q *Queries) ListPendingPeminjaman(ctx context.Context) ([]ListPendingPeminjamanRow, error) {
	rows, err := q.db.QueryContext(ctx, listPendingPeminjaman)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPendingPeminjamanRow
	for rows.Next() {
		var i ListPendingPeminjamanRow
		if err := rows.Scan(
			&i.PeminjamanID,
			&i.TglPinjam,
			&i.TglKembali,
			&i.Notes,
			&i.NamaInventaris,
			&i.NamaPeminjamUser,
			&i.UserIDPeminjam,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restorePeminjaman = `-- name: RestorePeminjaman :exec
UPDATE peminjaman
SET
    deleted_at = NULL,
    deleted_by = NULL
WHERE peminjaman_id = $1
`

func (q *Queries) RestorePeminjaman(ctx context.Context, peminjamanID string) error {
	_, err := q.db.ExecContext(ctx, restorePeminjaman, peminjamanID)
	return err
}

const softDeletePeminjaman = `-- name: SoftDeletePeminjaman :exec
UPDATE peminjaman
SET
    deleted_at = (now() at time zone 'UTC')::TIMESTAMP,
    deleted_by = $1
WHERE peminjaman_id = $2
`

type SoftDeletePeminjamanParams struct {
	DeletedBy    sql.NullString `json:"deleted_by"`
	PeminjamanID string         `json:"peminjaman_id"`
}

func (q *Queries) SoftDeletePeminjaman(ctx context.Context, arg SoftDeletePeminjamanParams) error {
	_, err := q.db.ExecContext(ctx, softDeletePeminjaman, arg.DeletedBy, arg.PeminjamanID)
	return err
}

const updatePeminjaman = `-- name: UpdatePeminjaman :one
UPDATE peminjaman
SET
    tgl_pinjam = $1,               -- Kembali ke nama kolom
    tgl_kembali = $2,             -- Kembali ke nama kolom
    status_peminjaman = $3::status_peminjaman_enum, -- Kembali ke nama kolom
    notes = $4,                         -- Kembali ke nama kolom
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $5                -- Kembali ke nama kolom
WHERE peminjaman_id = $6 AND deleted_at IS NULL -- Kembali ke nama kolom
    RETURNING id, user_id, peminjaman_id, inventaris_id, tgl_pinjam, tgl_kembali, status_peminjaman, notes, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type UpdatePeminjamanParams struct {
	TglPinjam        time.Time            `json:"tgl_pinjam"`
	TglKembali       time.Time            `json:"tgl_kembali"`
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	Notes            sql.NullString       `json:"notes"`
	UpdatedBy        sql.NullString       `json:"updated_by"`
	PeminjamanID     string               `json:"peminjaman_id"`
}

func (q *Queries) UpdatePeminjaman(ctx context.Context, arg UpdatePeminjamanParams) (Peminjaman, error) {
	row := q.db.QueryRowContext(ctx, updatePeminjaman,
		arg.TglPinjam,
		arg.TglKembali,
		arg.StatusPeminjaman,
		arg.Notes,
		arg.UpdatedBy,
		arg.PeminjamanID,
	)
	var i Peminjaman
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PeminjamanID,
		&i.InventarisID,
		&i.TglPinjam,
		&i.TglKembali,
		&i.StatusPeminjaman,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const updatePeminjamanStatus = `-- name: UpdatePeminjamanStatus :one
UPDATE peminjaman
SET
    status_peminjaman = $1::status_peminjaman_enum, -- Kembali ke nama kolom
    updated_at = (now() at time zone 'UTC')::TIMESTAMP,
    updated_by = $2 -- Kembali ke nama kolom
WHERE peminjaman_id = $3 AND deleted_at IS NULL -- Kembali ke nama kolom
    RETURNING id, user_id, peminjaman_id, inventaris_id, tgl_pinjam, tgl_kembali, status_peminjaman, notes, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type UpdatePeminjamanStatusParams struct {
	StatusPeminjaman StatusPeminjamanEnum `json:"status_peminjaman"`
	UpdatedBy        sql.NullString       `json:"updated_by"`
	PeminjamanID     string               `json:"peminjaman_id"`
}

func (q *Queries) UpdatePeminjamanStatus(ctx context.Context, arg UpdatePeminjamanStatusParams) (Peminjaman, error) {
	row := q.db.QueryRowContext(ctx, updatePeminjamanStatus, arg.StatusPeminjaman, arg.UpdatedBy, arg.PeminjamanID)
	var i Peminjaman
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PeminjamanID,
		&i.InventarisID,
		&i.TglPinjam,
		&i.TglKembali,
		&i.StatusPeminjaman,
		&i.Notes,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
